// Code generated by mockery v2.28.1. DO NOT EDIT.

package repository

import (
	s3 "github.com/aws/aws-sdk-go/service/s3"
	mock "github.com/stretchr/testify/mock"
)

// MockS3Repository is an autogenerated mock type for the S3Repository type
type MockS3Repository struct {
	mock.Mock
}

// GetBucketLocation provides a mock function with given fields: bucketName
func (_m *MockS3Repository) GetBucketLocation(bucketName string) (string, error) {
	ret := _m.Called(bucketName)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(bucketName)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(bucketName)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(bucketName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucketNotification provides a mock function with given fields: bucketName, region
func (_m *MockS3Repository) GetBucketNotification(bucketName string, region string) (*s3.NotificationConfiguration, error) {
	ret := _m.Called(bucketName, region)

	var r0 *s3.NotificationConfiguration
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*s3.NotificationConfiguration, error)); ok {
		return rf(bucketName, region)
	}
	if rf, ok := ret.Get(0).(func(string, string) *s3.NotificationConfiguration); ok {
		r0 = rf(bucketName, region)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.NotificationConfiguration)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(bucketName, region)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucketPolicy provides a mock function with given fields: bucketName, region
func (_m *MockS3Repository) GetBucketPolicy(bucketName string, region string) (*string, error) {
	ret := _m.Called(bucketName, region)

	var r0 *string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*string, error)); ok {
		return rf(bucketName, region)
	}
	if rf, ok := ret.Get(0).(func(string, string) *string); ok {
		r0 = rf(bucketName, region)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(bucketName, region)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucketPublicAccessBlock provides a mock function with given fields: bucketName, region
func (_m *MockS3Repository) GetBucketPublicAccessBlock(bucketName string, region string) (*s3.PublicAccessBlockConfiguration, error) {
	ret := _m.Called(bucketName, region)

	var r0 *s3.PublicAccessBlockConfiguration
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*s3.PublicAccessBlockConfiguration, error)); ok {
		return rf(bucketName, region)
	}
	if rf, ok := ret.Get(0).(func(string, string) *s3.PublicAccessBlockConfiguration); ok {
		r0 = rf(bucketName, region)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PublicAccessBlockConfiguration)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(bucketName, region)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAllBuckets provides a mock function with given fields:
func (_m *MockS3Repository) ListAllBuckets() ([]*s3.Bucket, error) {
	ret := _m.Called()

	var r0 []*s3.Bucket
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]*s3.Bucket, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []*s3.Bucket); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*s3.Bucket)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBucketAnalyticsConfigurations provides a mock function with given fields: bucket, region
func (_m *MockS3Repository) ListBucketAnalyticsConfigurations(bucket *s3.Bucket, region string) ([]*s3.AnalyticsConfiguration, error) {
	ret := _m.Called(bucket, region)

	var r0 []*s3.AnalyticsConfiguration
	var r1 error
	if rf, ok := ret.Get(0).(func(*s3.Bucket, string) ([]*s3.AnalyticsConfiguration, error)); ok {
		return rf(bucket, region)
	}
	if rf, ok := ret.Get(0).(func(*s3.Bucket, string) []*s3.AnalyticsConfiguration); ok {
		r0 = rf(bucket, region)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*s3.AnalyticsConfiguration)
		}
	}

	if rf, ok := ret.Get(1).(func(*s3.Bucket, string) error); ok {
		r1 = rf(bucket, region)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBucketInventoryConfigurations provides a mock function with given fields: bucket, region
func (_m *MockS3Repository) ListBucketInventoryConfigurations(bucket *s3.Bucket, region string) ([]*s3.InventoryConfiguration, error) {
	ret := _m.Called(bucket, region)

	var r0 []*s3.InventoryConfiguration
	var r1 error
	if rf, ok := ret.Get(0).(func(*s3.Bucket, string) ([]*s3.InventoryConfiguration, error)); ok {
		return rf(bucket, region)
	}
	if rf, ok := ret.Get(0).(func(*s3.Bucket, string) []*s3.InventoryConfiguration); ok {
		r0 = rf(bucket, region)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*s3.InventoryConfiguration)
		}
	}

	if rf, ok := ret.Get(1).(func(*s3.Bucket, string) error); ok {
		r1 = rf(bucket, region)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBucketMetricsConfigurations provides a mock function with given fields: bucket, region
func (_m *MockS3Repository) ListBucketMetricsConfigurations(bucket *s3.Bucket, region string) ([]*s3.MetricsConfiguration, error) {
	ret := _m.Called(bucket, region)

	var r0 []*s3.MetricsConfiguration
	var r1 error
	if rf, ok := ret.Get(0).(func(*s3.Bucket, string) ([]*s3.MetricsConfiguration, error)); ok {
		return rf(bucket, region)
	}
	if rf, ok := ret.Get(0).(func(*s3.Bucket, string) []*s3.MetricsConfiguration); ok {
		r0 = rf(bucket, region)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*s3.MetricsConfiguration)
		}
	}

	if rf, ok := ret.Get(1).(func(*s3.Bucket, string) error); ok {
		r1 = rf(bucket, region)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewMockS3Repository interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockS3Repository creates a new instance of MockS3Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockS3Repository(t mockConstructorTestingTNewMockS3Repository) *MockS3Repository {
	mock := &MockS3Repository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
